# AI記憶システム設計書

## コンセプト

AIの記憶装置は、人間の記憶に近い形で動作する。すべてを正確に記憶するのではなく、**解釈**して保存する。

## 従来の記憶システムとの違い

### 従来型
```
会話 → 保存 → 検索
```

### 新設計（心理優先記憶装置）
```
会話 → AI解釈 → 保存 → 検索
         ↓
    心理判定(1-100)
         ↓
    優先順位付け
         ↓
    容量管理
```

## 設計原理

1. **解釈保存**: 記憶する際はAIが解釈を加える
   - 元のコンテンツと解釈後のコンテンツの両方を保持
   - 「覚えること自体が創造」という考え方

2. **心理判定**: 各記憶に重要度スコア（1-100）を付与
   - AIが自律的に判断
   - ユーザー固有性を考慮
   - 感情的重要度を評価

3. **優先順位管理**: スコアに基づく優先順位
   - 高スコア = 重要な記憶
   - 低スコア = 忘れられやすい記憶

4. **容量制限**: 人間の記憶のように限界がある
   - 総容量制限（デフォルト: 100件）
   - 単発保存容量制限
   - 優先度が低いものから自動削除

## データ構造

```rust
struct Memory {
    id: String,                      // UUID
    content: String,                 // 元のコンテンツ
    interpreted_content: String,     // AI解釈後のコンテンツ
    priority_score: f32,             // 心理判定スコア (0.0-1.0)
    user_context: Option<String>,    // ユーザー固有性
    created_at: DateTime<Utc>,       // 作成日時
    updated_at: DateTime<Utc>,       // 更新日時
}
```

## 実装機能

### 1. 心理判定機能
- AI APIを使用して重要度を0.0-1.0で評価
- 判定基準:
  - 感情的インパクト (0.0-0.25)
  - ユーザーとの関連性 (0.0-0.25)
  - 新規性・独自性 (0.0-0.25)
  - 実用性 (0.0-0.25)

### 2. 保存機能
- 保存前にAI解釈を実行
- 心理判定スコアを自動付与
- 容量超過時は低スコアから削除

### 3. 検索機能
- 優先順位順にソート
- スコアによるフィルタリング
- セマンティック検索（オプション）

### 4. 容量管理
- デフォルト最大: 100件
- 設定可能な上限
- 自動プルーニング（低スコア削除）

## 実装ステップ

1. Memory構造体の拡張
2. AI解釈機能の実装（OpenAI API使用）
3. 心理判定機能の実装
4. 容量管理機能の実装
5. ソート・フィルタリング機能の強化
6. MCPツールへの統合

## 設定例

```json
{
  "max_memories": 100,
  "min_priority_score": 0.3,
  "auto_prune": true,
  "interpretation_enabled": true
}
```

## スコアリングシステムの哲学

0.0-1.0のfloat値を採用する理由：
- **正規化**: 機械学習やAIにとって扱いやすい標準形式
- **直感性**: 0が最低、1が最高という明確な基準
- **精度**: 0.75などの細かい値で微妙な重要度の差を表現可能
- **拡張性**: 時間軸(0.0-1.0)や確率(0.0-1.0)などとの統合が容易

この設計は、「I + o」概念（oの周りを0.0-1.0の時間軸で表す）とも整合性がある。

## ゲームのセーブデータとの類似性

- **Git = セーブ機能**: バージョン管理
- **GitHub = クラウドセーブ**: グローバルデータ共有
- **ATProto = データプロトコル**: 分散型データ保存
- **AI記憶 = プレイヤー記憶**: 経験の蓄積と解釈

ゲームのセーブデータも「プレイヤーの行動を解釈したデータ」として扱うことで、より意味のある永続化が可能になる。
